patch-package
--- a/node_modules/tslint/lib/rules/objectLiteralSortKeysRule.js
+++ b/node_modules/tslint/lib/rules/objectLiteralSortKeysRule.js
@@ -22,6 +22,7 @@ var ts = require("typescript");
 var Lint = require("../index");
 var OPTION_IGNORE_CASE = "ignore-case";
 var OPTION_MATCH_DECLARATION_ORDER = "match-declaration-order";
+var OPTION_SHORTHAND_FIRST = "shorthand-first";
 var Rule = /** @class */ (function (_super) {
     tslib_1.__extends(Rule, _super);
     function Rule() {
@@ -35,6 +36,9 @@ var Rule = /** @class */ (function (_super) {
         var type = typeName === undefined ? "its type declaration" : "'" + typeName + "'";
         return "The key '" + propName + "' is not in the same order as it is in " + type + ".";
     };
+    Rule.FAILURE_STRING_SHORTHAND_FIRST = function (name) {
+        return "The shorthand property '" + name + "' should appear before normal properties";
+    };
     Rule.prototype.apply = function (sourceFile) {
         var options = parseOptions(this.ruleArguments);
         if (options.matchDeclarationOrder) {
@@ -48,16 +52,16 @@ var Rule = /** @class */ (function (_super) {
     /* tslint:disable:object-literal-sort-keys */
     Rule.metadata = {
         ruleName: "object-literal-sort-keys",
-        description: (_a = ["\n            Checks ordering of keys in object literals.\n\n            When using the default alphabetical ordering, additional blank lines may be used to group\n            object properties together while keeping the elements within each group in alphabetical order.\n        "], _a.raw = ["\n            Checks ordering of keys in object literals.\n\n            When using the default alphabetical ordering, additional blank lines may be used to group\n            object properties together while keeping the elements within each group in alphabetical order.\n        "], Lint.Utils.dedent(_a)),
+        description: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["\n            Checks ordering of keys in object literals.\n\n            When using the default alphabetical ordering, additional blank lines may be used to group\n            object properties together while keeping the elements within each group in alphabetical order.\n        "], ["\n            Checks ordering of keys in object literals.\n\n            When using the default alphabetical ordering, additional blank lines may be used to group\n            object properties together while keeping the elements within each group in alphabetical order.\n        "]))),
         rationale: "Useful in preventing merge conflicts",
-        optionsDescription: (_b = ["\n            By default, this rule checks that keys are in alphabetical order.\n            The following may optionally be passed:\n\n            * \"", "\" will to compare keys in a case insensitive way.\n            * \"", "\" will prefer to use the key ordering of the contextual type of the object literal, as in:\n\n                interface I { foo: number; bar: number; }\n                const obj: I = { foo: 1, bar: 2 };\n\n            If a contextual type is not found, alphabetical ordering will be used instead.\n            "], _b.raw = ["\n            By default, this rule checks that keys are in alphabetical order.\n            The following may optionally be passed:\n\n            * \"", "\" will to compare keys in a case insensitive way.\n            * \"", "\" will prefer to use the key ordering of the contextual type of the object literal, as in:\n\n                interface I { foo: number; bar: number; }\n                const obj: I = { foo: 1, bar: 2 };\n\n            If a contextual type is not found, alphabetical ordering will be used instead.\n            "], Lint.Utils.dedent(_b, OPTION_IGNORE_CASE, OPTION_MATCH_DECLARATION_ORDER)),
+        optionsDescription: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject(["\n            By default, this rule checks that keys are in alphabetical order.\n            The following may optionally be passed:\n\n            * \"", "\" will compare keys in a case insensitive way.\n            * \"", "\" will prefer to use the key ordering of the contextual type of the object literal, as in:\n\n                interface I { foo: number; bar: number; }\n                const obj: I = { foo: 1, bar: 2 };\n\n            If a contextual type is not found, alphabetical ordering will be used instead.\n            * \"", "\" will enforce shorthand properties to appear first, as in:\n\n                const obj = { a, c, b: true };\n            "], ["\n            By default, this rule checks that keys are in alphabetical order.\n            The following may optionally be passed:\n\n            * \"", "\" will compare keys in a case insensitive way.\n            * \"", "\" will prefer to use the key ordering of the contextual type of the object literal, as in:\n\n                interface I { foo: number; bar: number; }\n                const obj: I = { foo: 1, bar: 2 };\n\n            If a contextual type is not found, alphabetical ordering will be used instead.\n            * \"", "\" will enforce shorthand properties to appear first, as in:\n\n                const obj = { a, c, b: true };\n            "])), OPTION_IGNORE_CASE, OPTION_MATCH_DECLARATION_ORDER, OPTION_SHORTHAND_FIRST),
         options: {
             type: "string",
-            enum: [OPTION_IGNORE_CASE, OPTION_MATCH_DECLARATION_ORDER],
+            enum: [OPTION_IGNORE_CASE, OPTION_MATCH_DECLARATION_ORDER, OPTION_SHORTHAND_FIRST],
         },
         optionExamples: [
             true,
-            [true, OPTION_IGNORE_CASE, OPTION_MATCH_DECLARATION_ORDER],
+            [true, OPTION_IGNORE_CASE, OPTION_MATCH_DECLARATION_ORDER, OPTION_SHORTHAND_FIRST],
         ],
         type: "maintainability",
         typescriptOnly: false,
@@ -69,13 +73,14 @@ function parseOptions(ruleArguments) {
     return {
         ignoreCase: has(OPTION_IGNORE_CASE),
         matchDeclarationOrder: has(OPTION_MATCH_DECLARATION_ORDER),
+        shorthandFirst: has(OPTION_SHORTHAND_FIRST),
     };
     function has(name) {
         return ruleArguments.indexOf(name) !== -1;
     }
 }
 function walk(ctx, checker) {
-    var sourceFile = ctx.sourceFile, _a = ctx.options, ignoreCase = _a.ignoreCase, matchDeclarationOrder = _a.matchDeclarationOrder;
+    var sourceFile = ctx.sourceFile, _a = ctx.options, ignoreCase = _a.ignoreCase, matchDeclarationOrder = _a.matchDeclarationOrder, shorthandFirst = _a.shorthandFirst;
     ts.forEachChild(sourceFile, function cb(node) {
         if (tsutils_1.isObjectLiteralExpression(node) && node.properties.length > 1) {
             check(node);
@@ -100,14 +105,31 @@ function walk(ctx, checker) {
             return;
         }
         var lastKey;
+        var lastPropertyWasShorthand;
         for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
             var property = _a[_i];
             switch (property.kind) {
                 case ts.SyntaxKind.SpreadAssignment:
                     lastKey = undefined; // reset at spread
+                    lastPropertyWasShorthand = undefined; // reset at spread
                     break;
                 case ts.SyntaxKind.ShorthandPropertyAssignment:
                 case ts.SyntaxKind.PropertyAssignment:
+                    if (shorthandFirst) {
+                        if (property.kind === ts.SyntaxKind.ShorthandPropertyAssignment) {
+                            if (lastPropertyWasShorthand === false) {
+                                ctx.addFailureAtNode(property.name, Rule.FAILURE_STRING_SHORTHAND_FIRST(property.name.text));
+                                return; // only show warning on first out-of-order property
+                            }
+                            lastPropertyWasShorthand = true;
+                        }
+                        else {
+                            if (lastPropertyWasShorthand === true) {
+                                lastKey = undefined; // reset on change to shorthand to normal
+                            }
+                            lastPropertyWasShorthand = false;
+                        }
+                    }
                     if (property.name.kind === ts.SyntaxKind.Identifier ||
                         property.name.kind === ts.SyntaxKind.StringLiteral) {
                         var key = ignoreCase ? property.name.text.toLowerCase() : property.name.text;
@@ -162,7 +184,7 @@ function hasBlankLineBefore(sourceFile, element) {
     });
 }
 function hasDoubleNewLine(sourceFile, position) {
-    return /(\r\n|\r|\n){2}/.test(sourceFile.text.slice(position, position + 4));
+    return /(\r?\n){2}/.test(sourceFile.text.slice(position, position + 4));
 }
 function getTypeName(t) {
     var parent = t.parent;
@@ -184,4 +206,4 @@ function getContextualType(node, checker) {
     var decl = declarations[0];
     return tsutils_1.isInterfaceDeclaration(decl) || tsutils_1.isTypeLiteralNode(decl) ? decl : undefined;
 }
-var _a, _b;
+var templateObject_1, templateObject_2;
